From a45aefc2fd0b785631c01fa6c56120602104883b Mon Sep 17 00:00:00 2001
From: Andrii Kroitor <an.kroitor@samsung.com>
Date: Thu, 21 Jul 2016 13:57:17 +0300
Subject: [PATCH] manualy applying commit
 62cf70034de38b17f2025e08f81b5758b3d6d6e3

From: Jaehwan Kim <jae.hwan.kim@samsung.com>
Date: Mon, 30 May 2016 09:47:39 +0900
Subject: [PATCH] widget: set the parent-child relation again, when the widget
 is unset

Summary:
When the widget is unset from any container, a parent of the widget
doesn't exist. So we should set its parent to the top object.
But if we just set sd->parent, the parent can not find the widget as a
child. So the container widgets set the parent-child relation when
sub object is unset.
This commit is related to 0822ad2195d335d65208856e6e590ac47691d920.

@fix
---
 src/lib/elc_popup.c    |  2 +-
 src/lib/elm_box.c      |  4 ++--
 src/lib/elm_flip.c     |  2 +-
 src/lib/elm_genlist.c  |  2 +-
 src/lib/elm_grid.c     |  4 ++--
 src/lib/elm_layout.c   | 22 +++++++++++-----------
 src/lib/elm_notify.c   |  2 +-
 src/lib/elm_panel.c    |  2 +-
 src/lib/elm_scroller.c |  4 ++--
 src/lib/elm_table.c    |  2 +-
 src/lib/elm_toolbar.c  |  6 +++---
 src/lib/elm_widget.h   | 10 ++++++++++
 12 files changed, 36 insertions(+), 26 deletions(-)

diff --git a/src/lib/elc_popup.c b/src/lib/elc_popup.c
index 9e8d041..2dae551 100644
--- a/src/lib/elc_popup.c
+++ b/src/lib/elc_popup.c
@@ -796,7 +796,7 @@ _item_icon_unset(Elm_Popup_Item_Data *it)
    Evas_Object *icon = it->icon;
 
    if (!it->icon) return NULL;
-   elm_widget_sub_object_del(WIDGET(it), icon);
+   _elm_widget_sub_object_redirect_to_top(WIDGET(it), icon);
    evas_object_data_del(icon, "_popup_icon_parent_item");
    eo_do(VIEW(it), elm_obj_container_content_unset(CONTENT_PART));
    elm_layout_signal_emit(VIEW(it), "elm,state,item,icon,hidden", "elm");
diff --git a/src/lib/elm_box.c b/src/lib/elm_box.c
index d37fd08..e65788b 100644
--- a/src/lib/elm_box.c
+++ b/src/lib/elm_box.c
@@ -531,7 +531,7 @@ _elm_box_unpack(Eo *obj, Elm_Box_Data *_pd EINA_UNUSED, Evas_Object *subobj)
    ELM_WIDGET_DATA_GET_OR_RETURN(obj, wd);
 
    if (evas_object_box_remove(wd->resize_obj, subobj))
-     elm_widget_sub_object_del(obj, subobj);
+     _elm_widget_sub_object_redirect_to_top(obj, subobj);
 }
 
 EOLIAN static void
@@ -545,7 +545,7 @@ _elm_box_unpack_all(Eo *obj, Elm_Box_Data *_pd EINA_UNUSED)
    ELM_BOX_CHECK(obj);
    bd = evas_object_smart_data_get(wd->resize_obj);
    EINA_LIST_FOREACH (bd->children, l, opt)
-     elm_widget_sub_object_del(obj, opt->obj);
+     _elm_widget_sub_object_redirect_to_top(obj, opt->obj);
 
    /* EINA_FALSE means to delete objects as well */
    evas_object_box_remove_all(wd->resize_obj, EINA_FALSE);
diff --git a/src/lib/elm_flip.c b/src/lib/elm_flip.c
index 820a822..30695f2 100644
--- a/src/lib/elm_flip.c
+++ b/src/lib/elm_flip.c
@@ -1765,7 +1765,7 @@ _flip_content_unset(Evas_Object *obj,
    if (!*cont) return NULL;
 
    content = *cont;
-   elm_widget_sub_object_del(obj, content);
+   _elm_widget_sub_object_redirect_to_top(obj, content);
 
    return content;
 }
diff --git a/src/lib/elm_genlist.c b/src/lib/elm_genlist.c
index bf46215..fc66765 100644
--- a/src/lib/elm_genlist.c
+++ b/src/lib/elm_genlist.c
@@ -6899,7 +6899,7 @@ _elm_genlist_item_all_contents_unset(Eo *eo_item EINA_UNUSED, Elm_Gen_Item *it,
 
    EINA_LIST_FREE(it->contents, content)
      {
-        elm_widget_sub_object_del(WIDGET(it), content);
+        _elm_widget_sub_object_redirect_to_top(WIDGET(it), content);
         edje_object_part_unswallow(VIEW(it), content);
         evas_object_hide(content);
         if (l) *l = eina_list_append(*l, content);
diff --git a/src/lib/elm_grid.c b/src/lib/elm_grid.c
index 2999faa..f347335 100644
--- a/src/lib/elm_grid.c
+++ b/src/lib/elm_grid.c
@@ -206,7 +206,7 @@ _elm_grid_unpack(Eo *obj, void *_pd EINA_UNUSED, Evas_Object *subobj)
 {
    ELM_WIDGET_DATA_GET_OR_RETURN(obj, wd);
 
-   elm_widget_sub_object_del(obj, subobj);
+   _elm_widget_sub_object_redirect_to_top(obj, subobj);
    evas_object_grid_unpack(wd->resize_obj, subobj);
 }
 
@@ -222,7 +222,7 @@ _elm_grid_clear(Eo *obj, void *_pd EINA_UNUSED, Eina_Bool clear)
      {
         chld = evas_object_grid_children_get(wd->resize_obj);
         EINA_LIST_FREE(chld, o)
-          elm_widget_sub_object_del(obj, o);
+          _elm_widget_sub_object_redirect_to_top(obj, o);
      }
 
    evas_object_grid_clear(wd->resize_obj, clear);
diff --git a/src/lib/elm_layout.c b/src/lib/elm_layout.c
index c16b8fe..f4d928c 100644
--- a/src/lib/elm_layout.c
+++ b/src/lib/elm_layout.c
@@ -683,7 +683,7 @@ _sub_box_remove(Evas_Object *obj,
    edje_object_part_box_remove
      (wd->resize_obj, sub_d->part, child);
 
-   if (!elm_widget_sub_object_del(obj, child))
+   if (!_elm_widget_sub_object_redirect_to_top(obj, child))
      {
         ERR("could not remove sub object %p from %p", child, obj);
         return NULL;
@@ -721,7 +721,7 @@ _sub_table_remove(Evas_Object *obj,
    edje_object_part_table_unpack
      (wd->resize_obj, sub_d->part, child);
 
-   if (!elm_widget_sub_object_del(obj, child))
+   if (!_elm_widget_sub_object_redirect_to_top(obj, child))
      {
         ERR("could not remove sub object %p from %p", child, obj);
         return NULL;
@@ -990,7 +990,7 @@ _elm_layout_elm_container_content_set(Eo *obj, Elm_Layout_Smart_Data *sd, const
               * edje_object_part_swallow()'s behavior, then */
              else if (content == sub_d->obj)
                {
-                  elm_widget_sub_object_del(obj, content);
+                  _elm_widget_sub_object_redirect_to_top(obj, content);
                   break;
                }
           }
@@ -1005,7 +1005,7 @@ _elm_layout_elm_container_content_set(Eo *obj, Elm_Layout_Smart_Data *sd, const
               (wd->resize_obj, part, content))
           {
              ERR("could not swallow %p into part '%s'", content, part);
-             elm_widget_sub_object_del(obj, content);
+             _elm_widget_sub_object_redirect_to_top(obj, content);
              return EINA_FALSE;
           }
 
@@ -1014,7 +1014,7 @@ _elm_layout_elm_container_content_set(Eo *obj, Elm_Layout_Smart_Data *sd, const
           {
              ERR("failed to allocate memory!");
              edje_object_part_unswallow(wd->resize_obj, content);
-             elm_widget_sub_object_del(obj, content);
+             _elm_widget_sub_object_redirect_to_top(obj, content);
              return EINA_FALSE;
           }
         sub_d->type = SWALLOW;
@@ -1090,7 +1090,7 @@ _elm_layout_elm_container_content_unset(Eo *obj, Elm_Layout_Smart_Data *sd, cons
              content = sub_d->obj; /* sub_d will die in
                                     * _elm_layout_smart_sub_object_del */
 
-             if (!elm_widget_sub_object_del(obj, content))
+             if (!_elm_widget_sub_object_redirect_to_top(obj, content))
                {
                   ERR("could not remove sub object %p from %p", content, obj);
                   return NULL;
@@ -1225,7 +1225,7 @@ _elm_layout_box_append(Eo *obj, Elm_Layout_Smart_Data *sd, const char *part, Eva
    if (!sub_d)
      {
         ERR("failed to allocate memory!");
-        elm_widget_sub_object_del(obj, child);
+        _elm_widget_sub_object_redirect_to_top(obj, child);
         edje_object_part_box_remove(wd->resize_obj, part, child);
         return EINA_FALSE;
      }
@@ -1264,7 +1264,7 @@ _elm_layout_box_prepend(Eo *obj, Elm_Layout_Smart_Data *sd, const char *part, Ev
    if (!sub_d)
      {
         ERR("failed to allocate memory!");
-        elm_widget_sub_object_del(obj, child);
+        _elm_widget_sub_object_redirect_to_top(obj, child);
         edje_object_part_box_remove(wd->resize_obj, part, child);
         return EINA_FALSE;
      }
@@ -1304,7 +1304,7 @@ _elm_layout_box_insert_before(Eo *obj, Elm_Layout_Smart_Data *sd, const char *pa
    if (!sub_d)
      {
         ERR("failed to allocate memory!");
-        elm_widget_sub_object_del(obj, child);
+        _elm_widget_sub_object_redirect_to_top(obj, child);
         edje_object_part_box_remove(wd->resize_obj, part, child);
         return EINA_FALSE;
      }
@@ -1347,7 +1347,7 @@ _elm_layout_box_insert_at(Eo *obj, Elm_Layout_Smart_Data *sd, const char *part,
    if (!sub_d)
      {
         ERR("failed to allocate memory!");
-        elm_widget_sub_object_del(obj, child);
+        _elm_widget_sub_object_redirect_to_top(obj, child);
         edje_object_part_box_remove(wd->resize_obj, part, child);
         return EINA_FALSE;
      }
@@ -1441,7 +1441,7 @@ _elm_layout_table_pack(Eo *obj, Elm_Layout_Smart_Data *sd, const char *part, Eva
    if (!sub_d)
      {
         ERR("failed to allocate memory!");
-        elm_widget_sub_object_del(obj, child);
+        _elm_widget_sub_object_redirect_to_top(obj, child);
         edje_object_part_table_unpack(wd->resize_obj, part, child);
         return EINA_FALSE;
      }
diff --git a/src/lib/elm_notify.c b/src/lib/elm_notify.c
index cec6104..2141c51 100644
--- a/src/lib/elm_notify.c
+++ b/src/lib/elm_notify.c
@@ -405,7 +405,7 @@ _elm_notify_elm_container_content_unset(Eo *obj, Elm_Notify_Data *sd, const char
    if (!sd->content) return NULL;
 
    content = sd->content;
-   elm_widget_sub_object_del(obj, sd->content);
+   _elm_widget_sub_object_redirect_to_top(obj, sd->content);
    edje_object_part_unswallow(sd->notify, content);
 
    return content;
diff --git a/src/lib/elm_panel.c b/src/lib/elm_panel.c
index bea0c3f..5f36934 100644
--- a/src/lib/elm_panel.c
+++ b/src/lib/elm_panel.c
@@ -994,7 +994,7 @@ _elm_panel_elm_container_content_unset(Eo *obj, Elm_Panel_Data *sd, const char *
 
    evas_object_box_remove_all(sd->bx, EINA_FALSE);
    if (sd->scrollable)
-     elm_widget_sub_object_del(sd->scr_ly, sd->content);
+     _elm_widget_sub_object_redirect_to_top(sd->scr_ly, sd->content);
    sd->content = NULL;
 
    return ret;
diff --git a/src/lib/elm_scroller.c b/src/lib/elm_scroller.c
index 1b5011c..0300126 100644
--- a/src/lib/elm_scroller.c
+++ b/src/lib/elm_scroller.c
@@ -833,9 +833,9 @@ _elm_scroller_elm_container_content_unset(Eo *obj, Elm_Scroller_Data *sd, const
 
    ret = sd->content;
    if (sd->loop_h || sd->loop_v)
-     elm_widget_sub_object_del(obj, sd->contents);
+     _elm_widget_sub_object_redirect_to_top(obj, sd->contents);
    else
-     elm_widget_sub_object_del(obj, sd->content);
+     _elm_widget_sub_object_redirect_to_top(obj, sd->content);
    eo_do(obj, elm_interface_scrollable_content_set(NULL));
    sd->content = NULL;
 
diff --git a/src/lib/elm_table.c b/src/lib/elm_table.c
index 1a4d01a..1738773 100644
--- a/src/lib/elm_table.c
+++ b/src/lib/elm_table.c
@@ -334,7 +334,7 @@ _elm_table_unpack(Eo *obj, void *_pd EINA_UNUSED, Evas_Object *subobj)
 {
    ELM_WIDGET_DATA_GET_OR_RETURN(obj, wd);
 
-   elm_widget_sub_object_del(obj, subobj);
+   _elm_widget_sub_object_redirect_to_top(obj, subobj);
    evas_object_table_unpack(wd->resize_obj, subobj);
 }
 
diff --git a/src/lib/elm_toolbar.c b/src/lib/elm_toolbar.c
index 5d46d1f..4cc083a 100644
--- a/src/lib/elm_toolbar.c
+++ b/src/lib/elm_toolbar.c
@@ -1635,7 +1635,7 @@ _elm_toolbar_item_elm_widget_item_part_content_unset(Eo *eo_item EINA_UNUSED, El
      }
 
    elm_layout_content_unset(VIEW(item), "elm.swallow.object");
-   elm_widget_sub_object_del(obj, item->object);
+   _elm_widget_sub_object_redirect_to_top(obj, item->object);
    o = item->object;
    item->object = NULL;
    scale = (elm_widget_scale_get(obj) * elm_config_scale_get());
@@ -2453,7 +2453,7 @@ _elm_toolbar_item_icon_update(Elm_Toolbar_Item_Data *item)
      elm_layout_content_get(VIEW(item), "elm.swallow.icon");
    Eina_List *l;
 
-   elm_widget_sub_object_del(WIDGET(item), old_icon);
+   _elm_widget_sub_object_redirect_to_top(WIDGET(item), old_icon);
    elm_layout_content_set(VIEW(item), "elm.swallow.icon", item->icon);
    if (item->icon)
        elm_layout_signal_emit(VIEW(item), "elm,state,icon,visible", "elm");
@@ -2518,7 +2518,7 @@ _elm_toolbar_item_icon_obj_set(Evas_Object *obj,
             (VIEW(item), "elm.swallow.icon_new");
         if (old_icon)
           {
-             elm_widget_sub_object_del(WIDGET(item), old_icon);
+             _elm_widget_sub_object_redirect_to_top(WIDGET(item), old_icon);
              evas_object_hide(old_icon);
           }
         elm_layout_content_set
diff --git a/src/lib/elm_widget.h b/src/lib/elm_widget.h
index e553ec5..4355de4 100644
--- a/src/lib/elm_widget.h
+++ b/src/lib/elm_widget.h
@@ -846,6 +846,16 @@ EAPI Eina_Bool        _elm_widget_item_onscreen_is(Elm_Object_Item *item);
          }                                                      \
   } while (0)
 
+static inline Eina_Bool
+_elm_widget_sub_object_redirect_to_top(Evas_Object *obj, Evas_Object *sobj)
+{
+   Eina_Bool ret = elm_widget_sub_object_del(obj, sobj);
+   if (ret)
+      ret = elm_widget_sub_object_add(elm_widget_top_get(obj), sobj);
+
+   return ret;
+}
+
 /* to be used by INTERNAL classes on Elementary, so that the widgets
  * parsing script skips it */
 #define ELM_INTERNAL_SMART_SUBCLASS_NEW EVAS_SMART_SUBCLASS_NEW
-- 
2.7.4

